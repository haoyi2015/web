# 什么是作用域链，什么是原型链，原型，闭包
---
## 作用域链
> **红宝书** 中对作用域链是这么描述：**当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问**；
通俗点说就是作用域是针对变量的。（标识符）
比如我们创建一个函数，此函数包含另一个函数，函数里面还包含变量，此时就有三层作用域【全局作用域——第一个函数作用域——第二个函数作用域】

栗子：
```
var name ="一个栗子"
function fun(){
    console.log(name) //undefined
    var name = "fun内的一个栗子"
    console.log(name) // fun内的一个栗子
    function fun1(){
        var name = "fun1内的一个栗子"
        console.log(name) //fun1内的一个栗子
    }
    fun1()
}
fun() // 最终输出undefined——fun内的一个栗子——fun1内的一个栗子
在执行fun时会去找name变量，且fun函数内有申明name但输出是在申明赋值之前，所有输出是未定义————undefined；而fun函数里面的第二个输出自然是定义赋值之后所以输出————fun内的一个栗子；fun1里面的输出是在此函数里面定义name之后输出的，固然值就是————fun1内的一个栗子，而不会往上查找name变量
```
**一直会找到全局变量name这个查找的过程就叫作用域链，也就是会从当前层一层一层往上找一直找到全局name为止**

疑问？？

> 函数fun1为什么可以在函数fun中查找变量name，因为函数fun1是在函数fun中创建的，也就是说函数fun1的作用域包括了函数fun的作用域，当然也包括了全局作用域，但是函数fun不能向函数fun1中查找变量，**因为作用域只会向上查找**
> 
> 注意：执行环境（执行上下文）全局执行环境，函数执行环境
> 执行环境是JavaScript中最为重要的一个概念。执行函数定义了变量或函数有权访问的其它数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable
> object）和一个作用域链（scope chain），环境中定义的所以变量和函数都保存在其变量对象中
> 
> 活动对象：在一个函数对象被调用的时候，会创建一个活动对象，首先将该函数的每个形参和实参，都添加为该活动对象的属性和值；将该函数体内显示声明的变量和函数，也添加为该活动的的属性（在刚进入该函数执行环境时，未赋值，所以值为undefined，这个是JS的提前声明机制）

## 什么是原型链？？
原型链是针对构造函数（引用类型）
创建一个函数，然后通过变量new这个函数，此时被new出来的函数就会继承开始创建的函数的属性，然后访问new出来的函数的某个属性，但是在new出来的函数中木有定义这个属性，此时就会一直往上找（开始创建的函数中）这个过程就是原型链

所有函数的默认原型都是Object的实例
**Object ==> 构造函数1 ==> 构造函数2**

```
function fun(){}
fun.prototype.name = "一个栗子"
var fn = new fun()
fn.name // 一个栗子

new的过程：
1—— 创建新的对象，函数this指向新函数，（改变this）
2—— 执行函数
3—— 返回新函数的对象
```

## 闭包

> 函数在定义的词法作用域以外的地方被调用，闭包使得函数可以继续访问定义时的词法作用域。

```
function fn(){
    var a = 'JavaScript';
    function func(){
        console.log(a);
    }
    return func;
}

var func = fn();
func(); //JavaScript

分析：
func函数执行的位置和定义的位置是不相同的，func是在函数fn中定义的，但执行却是在全局环境中，虽然是在全局函数中执行的，但函数仍然可以访问当定义时的词法作用域
```


+ 作用域链：

> **内部环境可以通过作用域链来访问外部环境的属性和方法，但是，外部环境不能访问内部环境的任何属性和方法。注意，只能通过定义函数来延长作用域链条**

+ 闭包：

> **是一个能够读取其他函数内的变量的函数，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成（定义在一个函数内部的函数），可以理解为——————闭包就是将函数内部和函数外部连接起来的一座桥梁**

栗子：
```
function a (){
    var name = "一个栗子"
    function b(){
        console.log(name)
    }
    return b
}
var c = a()
c()
分析：
函数b就是一个闭包函数，用于获取函数a内部的变量name。当函数a的内部函数b被函数a外的一个变量c引用的时候，就创建了一个闭包

作用：
1————可以读取函数内部的变量
2————让这些变量的值始终保持在内存中

不好处：
1————变量保存在内存中，消耗性能，退出去删除不需要的变量
2————闭包会在父函数外部，改变父函数内部变量的值
     如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值
```
+ 原型链：

> **原型**——所有的函数都有一个特殊的属性prototype(原型)，prototype属性是一个指针，指向的是一个对象(原型对象)，原型对象中的方法和属性都可以被函数的实例所共享。所谓的函数实例是指以函数作为构造函数创建的对象，这些对象实例都可以共享构造函数的原型的方法。
> 
> **原型链**——原型链是用于查找引用类型（对象）的属性，查找属性会沿着原型链依次进行，如果找到该属性会停止搜索并做相应的操作，否则将会沿着原型链依次查找直到结尾。常见的应用是用在创建对象和继承中。