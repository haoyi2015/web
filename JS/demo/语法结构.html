<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>语法结构</title>
	<link rel="stylesheet" href="">
</head>
<body>
	<script type="text/javascript">
		console.log('kkkkkkkkk\u000C111')
		document.write("kkkkkkkkk\u000C111")
		document.write("<br>")
		document.write("kkkkkkkkk\u200Fdkjlkklkls")

		//javascript注释

		// 单行注释

		/* var test = 1 */ // 段注释

		/*
			* 段注释
			* 段注释
		*/

		// 直接量

		console.log(111); console.log("test")
		console.log({x:0,y:9})

		var msg = "hello, first"
		console.log(msg.charAt(msg.length-1))

		console.log(msg.substring(1,3))
		console.log(msg.slice(1,3))
		console.log(msg.slice(-3))
		console.log(msg.indexOf("l"))
		console.log(msg.lastIndexOf("l"))
		console.log(msg.indexOf("l",1))
		console.log(msg.split('/'))
		console.log(msg.replace("h","H"))
		console.log(msg.toUpperCase())

		console.log(msg[2])

		var asn = /\d+/g
		console.log(asn.test('hhhhh'))
		console.log('h2h3hh6h'.match(asn))
		console.log('jsj888jjj98ffff'.replace(asn,"#"))
		console.log('iiisjs888'.split(asn))

		var a = 111,b = 90

		if(a==111&&b==100){
			console.log(1)
		}
		console.log(b==100)
		console.log((a==0&&b==0)||!(b==100))

		spo = "mmm"
		function am() {
			spo = "909"
			mk = '9990'
			return [spo,mk]
		}
		var mk =9997
		console.log(mk)
		console.log(am())

		function ks() {
			var i =10;
			if(true){
				var j = 100
			}
			console.log(j)
		}
		ks()

		var spc = 1000

		ms = 1112111

		function ml() {
			console.log(spc)
			var spc = "1111"
			console.log(spc)
		}
		ml()
		console.log(delete this.ms,"ppppp")

		var obj = {name: 1222,age:10,sex:"数据"}
		//var obj1 = {name: 1222,age:10,sex:"11数据"}

		var obj1 = obj
		obj.name = 22
		console.log(obj.name)

		var nums = [2, 7, 11, 15], target = 9;
		var sub = 0

		/*for(var i = 0; i<nums.length; i++){
			for(var j = i+1; j<nums.length; j++){
				if(nums[i] + nums[j] == target){
					return [i,j]
				}
			}
		}*/
		var p ={
			name: 89,
			age: 19
		}
        function pops(name){
        	this.name = name
        }
		pops.prototype = p
		var m = new pops('22222')
		console.log(m.age)

		// 九九乘法表
		var table = new Array(10)

		for(var i = 0; i<table.length; i++)
			table[i] = new Array(10)
			for(var row = 0; row < table.length; row++){
				for(var col = 0; col < table[row].length; col++){
					table[row][col] = row*col
					console.log(row*col)
				}
			}

			var vals = table[5][7]
			console.log(vals)

		var x = 123
			x = x.toString()
		console.log(x.split("").reverse().join(''))

		console.log(x.indexOf('-')>-1?false:true)


		// 注意： this的指向在函数创建的时候是决定不了的
		/**
		 * 参考题目Question 1
		 * this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象
		 * new 可改变this指向
		 */

		var name = 'window'

		var person1 = {
		  name: 'person1',
		  show1: function () {
		    console.log(this.name)
		  },
		  show2: () => console.log(this.name),
		  show3: function () {
		    return function () {
		      console.log(this.name)
		    }
		  },
		  show4: function () {
		    return () => console.log(this.name)
		  }
		}
		var person2 = { name: 'person2' }

		person1.show1()  // show 函数是被person1对象调用
		person1.show1.call(person2) // 对show1改变了指向

		person1.show2() //指向window
		person1.show2.call(person2) //指向window

		person1.show3()() // 直接执行 指向window
		person1.show3().call(person2) // 指向person2对象
		person1.show3.call(person2)() // 指向window

		person1.show4()() // 指向person1
		person1.show4().call(person2) // 指向person1
		person1.show4.call(person2)() //先通过person2执行了show4方法

		var ops = {
		    name: 'aaa',
		    b:{
		    	name: 'bbb',
			    fu: function(){
			    	(()=>{
			    		console.log(this) // 箭头函数this不可改变
			    	})()
			    },
			    fun: function () {
			    	console.log(this,'---')
				    return () => console.log(this)
				}
		    }
		}
		ops.b.fun().call(person2)  // b调用了fun函数，fun函数this指向b对象，而fun又调用了箭头函数，箭头函数this指向show4函数的this也就是b对象
		//var s = ops.fu()
		//s() // 相当于window调用
		var obj = {
		    name: 'obj',
		    fun: function() {
		        console.log(this,' 11') // 指向obj对象
		    },
		    b:{
		    	name: 'bbb',
			    fun1:function () {
			    	console.log(this,' 22') // 指向b对象
			    },
			    c:{
			    	name: 'ccc',
				    fun2:function () {
				    	console.log(this,' 333') // 指向c对象
				    },
				    fun4:function () {
				    	return function () {
					      console.log(this)
					    }
				    },
				    fun5:function () {
				    	return () => console.log(this)
				    },
				    fun3:() => console.log(this) // 指向window
			    }
		    }
		}
		obj.b.c.fun4()()  // fun4返回了一个函数，通过()对此函数执行，相当于放到全局执行
		obj.b.c.fun5()()  // 箭头函数this指向上级this








		/**
		 * 参考题目Question 2
		 */
		var name = 'window'

		function Person (name) {
		  this.name = name;
		  this.show1 = function () {
		    console.log(this.name)
		  }
		  this.show2 = () => console.log(this.name)
		  this.show3 = function () {
		    return function () {
		      console.log(this.name)
		    }
		  }
		  this.show4 = function () {
		    return () => console.log(this.name)
		  }
		}

		var personA = new Person('personA')
		var personB = new Person('personB')

		personA.show1() // personA
		personA.show1.call(personB) // personB

		personA.show2() // personA
		personA.show2.call(personB) // personA

		personA.show3()() // window放全局执行
		personA.show3().call(personB) // personB
		personA.show3.call(personB)() // window

		personA.show4()() // personA
		personA.show4().call(personB) // personA
		personA.show4.call(personB)()  // personB

		/*new 操作符调用构造函数，实际上会经历一下4个步骤：

		创建一个新对象；
		将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；
		执行构造函数中的代码（为这个新对象添加属性）；
		返回新对象*/

		/*
			题目三
			变量申明提升
			原始地址 https://www.cnblogs.com/xxcanghai/p/5189353.html
		*/
		function Foo() {
			// 此处getName是全局
		    getName = function () { console.log (1); };
		    //this.getName = function () { console.log(8) }
		    return this;
		}
		Foo.getName = function () { console.log (2);};

		Foo.prototype.getName = function () { console.log (3);};

		var getName = function () { console.log (4);}; // 提升函数声明，覆盖var的声明

		function getName() { console.log (5);} //只提升变量声明 最终的赋值再次覆盖function getName声明

		//请写出以下输出结果：
		Foo.getName(); // 2 Foo上绑定了getName函数
		getName(); // 4 getName //局部大于全局   【所有声明变量或声明函数都会被提升到当前函数的顶部】
		Foo().getName(); // 1  执行的是Foo函数下面的getName 【考察一个是变量作用域问题，一个是this指向问题】
		getName(); // 1 调用的函数Foo里面的getName  因为Foo函数执行了
		new Foo.getName(); // 2 Foo上绑定了一个getName函数
		/*
			（.）的优先级高于new操作
			new Foo.getName() 相当于 new (Foo.getName)()
		*/
		new Foo().getName(); // 3 实力了Foo
		/*
			括号高于new先执行
			(new Foo()).getName()  
			先执行Foo函数，Foo此时作为构造函数却有返回值
			构造函数返回了实例化对象 {}
			如果构造函数实例化返回值的是
			基本类型：（string,number,boolean,null,undefined）则与无返回值相同
			引用类型： 则实际返回值为这个引用类型  【题目中返回的是this，而this在构造函数中本来就代表当前实例化对象，所以Foo函数返回实例化对象】
			特别注意：因为在Foo构造函数中没有为实例化对象添加任何属性，遂到当前对象的原型对象（prototype）中寻找getName
		*/
		new new Foo().getName(); // 3
		/*
			优先级
			实际执行 new ((new Foo()).getName)();
			先初始化Foo实列对象，然后将其原型上的getName函数作为构造函数再次new
		*/
		console.log(new Foo().getName())
	</script>
</body>
</html>