<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title></title>
	<link rel="stylesheet" href="">
</head>
<body>
	<script type="text/javascript">
		
		const aa = [1,[1,2,3],{name:1}];
		const bb = aa.concat(); // aa.slice()
		console.log(bb === aa); // false
		bb[1].push(4);
		bb[2].name = 2; 
		//console.log(aa); // [1,[1,2,3,4],{name:2}]
        // 展开运算符
        [... aa]
		console.log(Object.assign({},{name:112}))

        /*
            1. 赋值运算符 = 实现的是浅拷贝，只拷贝对象的引用值；
            2. JavaScript 中数组和对象自带的拷贝方法都是“**首层浅拷贝**”；
            3. JSON.stringify 实现的是深拷贝，但是对目标对象有要求；
            4. 若想真正意义上的深拷贝————递归
        */

		// 递归实现深拷贝
		function deepClone(source) {
		    var target = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象
		    for (let keys in source) { // 遍历目标
		        if (source.hasOwnProperty(keys)) {
		            if (source[keys] && typeof source[keys] === 'object') { // 如果值是对象，就递归一下
		                target[keys] = source[keys].constructor === Array ? [] : {};
		                target[keys] = deepClone(source[keys]);
		            } else { // 如果不是，就直接赋值
		                target[keys] = source[keys];
		            }
		        }
		    }
		    return target;
		}
		console.log(deepClone(aa))

        // 浅拷贝
		function shallowClone(copyObj) {
		  var obj = {};
		  for ( var i in copyObj) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                obj[i] = copyObj[i];
                // 判断是否是对象object
            }
		  }
		  return obj;
		}
	</script>
</body>
</html>